

1. vue设置自定义属性： ：加属性名，可设置动态的，比如自定义属性id,且id是动态设置的数组内的属性

    :id = "item.id"

   读取自定义属性： event.target.getAttribute('id')



   vue设置自定义数据， 用data-*

   读取自定义数据： this.$refs.liId.dataset.id

        
<li class="item" :id="item.id" v-for="item in items" :key="item.index" ref="liId"  data-id="wwww"  @click="navTab('$event')">{{item.tabName}}</li>



2.tab切换： 判断数字和自定义的数字是否一致
判断绑定哪个class的写法

:class="[ isActive == 0 ? 'itemActive' : '']" data-num="0"



<li class="item" @click="navTab($event)"  :class="[ isActive == 2 ? 'itemActive' : '']" data-num="2">
    <router-link to="/" :class="[ isActive == 2 ? 'txtActive' : '']">烘焙</router-link>
</li>

      navTab(e){
          let num = e.currentTarget.dataset.num         //获取点击元素的自定义数据
          console.log(e.currentTarget, num)
          this.isActive = num
      }


3.设置动态样式

   :style="{left: left + 'px'}"


4.获取点击元素的自定义数据
 e.currentTarget.dataset.num

 e.currentTarget.offsetLeft        //获取点击元素距离左边距的距离



5.keep-alive 使路由或某个组件不刷新,保存原来的信息

6.$router 和 $route 的区别

$route为当前router跳转对象里面可以获取name、path、query、params等

$router为VueRouter实例，想要导航到不同URL，则使用$router.push方法

返回上一个history也是使用$router.go方法


7.vue-router的两种模式：hash(带#) 和 history（不带#，需要后台配置，要不然刷新时会出现404）


8.动态设置路由：

<route-link :to="path"></route-link>

监听路由的变化：

watch:{
    $route(val){                             //监听路由的变化
      console.log(val)                      //val  ======== this.route       
    }
  }



9. vue-router导航切换 时，如果两个路由都渲染同个组件，组件会重（chong）用,组件的生命周期钩子不会再被调用,使得组件的一些数据无法根据 path的改变得到更新



data () {
    return {
      path:this.$router.currentRoute.path;
    }
}
watch: {
      '$route' (to, from) {
        this.path = this.$router.currentRoute.path 
      }
}



10.为什么要加key？ (https://www.cnblogs.com/zhumingzhenhao/p/7688336.html)

当页面的数据发生变化时，Diff算法只会比较同一层级的节点：

	如果节点类型不同(不一样的标签)，直接干掉前面的节点，再创建并插入新的节点，不会再比较这个节点以后的子节点了。

	如果节点类型相同(一样的标签)，则会重新设置该节点的属性，从而实现节点的更新。


   所以我们需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点

所以一句话，key的作用主要是为了高效的更新虚拟DOM。另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，

否则vue只会替换其内部属性而不会触发过渡效果。


10.24

node服务器和前端服务器域名，接口一样时，都启动的话，接口地址会出现 cannot get /XXX 的错误，解决办法：node的服务器和前端服务器设置不同的域名


10.25

1.header头三件套

header(‘Access-Control-Allow-Origin :’.$origin); //允许的域名（ * 所有域） 
header(‘Access-Control-Allow-Methods : POST’); //允许的方法 
header(‘Access-Control-Allow-Headers : x-requested-with , content-type’); //服务器支持的头信息


2.请求来的数据是异步的，渲染是同步的，所以先判断是不是有数据了，再进行渲染，否则报如下错误

[Vue warn]: Error in render: "TypeError: Cannot read property 'name' of undefined"

解决方法：加上判断条件

<el-row v-if="classification.length > 0">   
    <Classification :classificationName = "classification[0].name" :items = "classification[0].classificationImg"></Classification>
</el-row>



3.Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。
$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM



4.slot

父组件引用子组件时，一般子组件的开闭标签中间是不加内容的（<Children></Children>），如果加了<Children> <span>替换子组件中对应的slot</span> </Children>）,那么里面的内容元素就会替换子组件中对应的slot，如果没有内容，就会显示子组件中slot的内容


5.v-for不能用于根元素（root element）。因为v-for是个循环，它返回更多的元素。导致无法渲染

  嵌套循环：子循环是父循环数据中的数据‘

 <el-row class="hang" :key="index" v-for="(Pitem, index) in Pitems">

    <router-link tag="li" to="" :key="index" v-for="(item,index) in Pitem.classificationImg"></router-link>

</el-row> 









